<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>サポート ライブラリのできるまで</title>
    <style>
      @import url(http://fonts.googleapis.com/earlyaccess/notosansjapanese.css);

      body {
        font-family: 'Noto Sans Japanese', sans-serif;
      }

      a {
        text-decoration: none;
        color: blue;
      }

      a:visited {
        color: blue;
      }

      a:hover {
        text-decoration: underline;
      }

      li {
        line-height: 1.8;
      }

      h1, h2, h3 {
        font-family: 'Noto Sans Japanese', sans-serif;
        font-weight: bold;
      }

      .chapter-1.normal {
        background-image: linear-gradient(180deg, #3F51B5 50%, #FFFFFF 50%);
      }

      .chapter-1.hero {
        background-color: #3F51B5;
      }

      .chapter-2.normal {
        background-image: linear-gradient(180deg, #F44336 50%, #FFFFFF 50%);
      }

      .chapter-2.hero {
        background-color: #F44336;
      }

      .chapter-3.normal {
        background-image: linear-gradient(180deg, #009688 50%, #FFFFFF 50%);
      }

      .chapter-3.hero {
        background-color: #009688;
      }

      .chapter-4.normal {
        background-image: linear-gradient(180deg, #E91E63 50%, #FFFFFF 50%);
      }

      .chapter-4.hero {
        background-color: #E91E63;
      }

      .chapter-5.normal {
        background-image: linear-gradient(180deg, #FF5722 50%, #FFFFFF 50%);
      }

      .chapter-5.hero {
        background-color: #FF5722;
      }

      /* ページ番号 */
      .remark-slide-number {
        color: #CCCCCC;
        font-size: 12pt;
        opacity: 1;
      }

      .hero h1, .hero h2, .hero h3 {
        color: #FFFFFF;
      }

      .hero h2 {
        margin-left: 1em;
      }

      .normal {
        background-position: right 0em bottom 8em;
      }

      .normal h1 {
        color: white;
        margin-top: 0px;
        margin-left: 1em;
        font-size: 28pt;
      }

      .normal h2 {
        margin: 0px;
        font-size: 18pt;
      }

      .remark-code, .remark-inline-code {
        font-family: monospace;
      }

      code {
        border-radius: 4px;
        max-height: 400px;
      }

      .hljs-googlecode .hljs {
        background-color: #EEEEEE;
        overflow-y: auto;
        overflow-x: hidden;
      }

      .card {
        background-color: white;
        border-radius: 0.1em;
        padding: 1em 2em;
        box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
      }

      .card img {
        float: right;
        margin-left: 8px;
        max-width: 32%;
        max-height: 32%;
      }

    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, hero, chapter-1

# <nobr>サポート ライブラリの<wbr>できるまで</nobr>

---

class: normal, chapter-1

# 自己紹介

.card[
![近影](../images/yaraki.png)

荒木佑一

[@yuichi_araki](https://twitter.com/yuichi_araki)

Developer Programs Engineer

- Google I/O アプリ
- Google サンタを追いかけよう for Android
- [d.android.com/samples](http://d.android.com/samples) のサンプル
  - MIDI 関連
  - Camera2 関連
  - Android for Work 関連
  - ScreenCapture
  - Transition 関連
]

---

class: center, middle, hero, chapter-1

# <nobr>Android Design <wbr>Support Library</nobr>

---

class: normal, chapter-1

# それは何

.card[
![cheesesquare](cheesesquare.png)

Material Design のコンポーネント群

- FloatingActionButton
- Snackbar
- CoordinatorLayout
- AppBar
- CollapsingToolbarLayout
- TextInputLayout
- TabLayout
- NavigationView

サンプル: [github.com/chrisbanes/cheesesquare](https://github.com/chrisbanes/cheesesquare)
]

---

class: normal, chapter-1

# 立ち位置

.card[
## Support v4
- v4 以降に追加された API のバックポート
- リソースなし

## AppCompat
- v7 以降に追加された UI 関係の API のバックポート
- リソースあり
- Support v4 に依存

## Design
- プラットフォームにはない
- AppCompat v7 と RecyclerView に依存
]

???

なぜ既存のライブラリに機能を追加するのではなく、新規にライブラリを作成したか

どこに何があるかわからなくなったときの参考に

RecyclerView には 23.1.0 から依存するようになりました

---

class: normal, chapter-1

# 歴史

.card[
2014/06: Google I/O 2014  
[Material Design を発表](https://www.youtube.com/watch?v=Q8TXgCzxEnw)

2014/10: Android 5.0 Lollipop リリース

2014/12: 企画開始

2015/01: 開発開始

2015/05: Google I/O 2015  
Design Support Library をリリース (バージョン 22.2.0)

(略)

2015/11: バージョン 23.1.1
]

???

- I/O 2014 アプリ
  - 非マテリアル版とマテリアル版の 2 種類ありました
  - Design ライブラリはありませんでした
- I/O 2015 アプリ
  - Design ライブラリをつかった最初のアプリ

バージョン番号
- 1 つ目はフレームワークの最新 API レベル
- 2 つ目はライブラリの API が変更されたときにあげられる
- 3 つ目は (基本的に) API 変更を伴わないバグフィックス、改善

---

class: normal, chapter-1

# 使い方

.card[
Android Design Support Library について  
http://googledevjp.blogspot.jp/2015/07/android-design-support-library.html

Android サポート ライブラリ 23.1 のご紹介  
http://googledevjp.blogspot.jp/2015/11/android-231.html

Techbooster Android Masters!  
https://techbooster.booth.pm/items/126263
]

???

その他インターネットで検索するとたくさん見つかります

今回は使い方の話は最低限にとどめて、この Design サポート ライブラリができるまでの話をします

---

class: center, middle, hero, chapter-2

# 23.1.0, 23.1.1 の変更点

---

class: normal, chapter-2

# AppBar の layout_scrollFlags で snap

.card[
AppBar 内の要素が部分的に表示されている状態を避ける

```xml
<android.support.design.widget.CoordinatorLayout ... >

    <android.support.design.widget.AppBarLayout ... >

        <android.support.v7.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary"
            app:popupTheme="@style/ThemeOverlay.AppCompat.Light"
            `app:layout_scrollFlags="scroll|enterAlways|snap"` />

        ...

    </android.support.design.widget.AppBarLayout>

</android.support.design.widget.CoordinatorLayout>
```
]

???

- AppBarLayout はアップバー (アクションバー) を作るコンポーネント
- CoordinatorLayout に入れて使う
- Toolbar を入れたり、TabLayout でタブをつけたり、CollapsingToolbarLayout でパララックスな背景をつけたり
- 例は cheesesquare から

---

class: normal, chapter-2

# TextInputLayout の文字数カウンター

.card[
![TextInputLayout スクリーンショット](til-counter.png)

自動的に入力文字数をカウントする

```xml
<android.support.design.widget.TextInputLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        `app:counterEnabled="true"`
        `app:counterMaxLength="30"`>

    <EditText
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="@string/description"/>

</android.support.design.widget.TextInputLayout>
```

- TextView の android:maxLength と違って、制限数を超えて入力できる
]

???

- TextInputLayout は EditText の機能を補強するコンポーネント
- エラー表示、ヒントのフロート表示など
- 新しく文字数カウンターが入った
- Java から使うなら setCounterEnabled, setCounterMaxLength
- エラー表示とも共存できる

---

class: normal, chapter-2

# NavigationView の app:actionLayout

.card[
![NavigationView スクリーンショット](nv-actionlayout.png)

NavigationView の項目の右端に任意のレイアウトを配置する

```xml
<menu ...>
  <group android:checkableBehavior="single">

    <item
      android:id="@+id/navigation_item_3"
      android:icon="@drawable/ic_android"
      android:title="@string/navigation_item_3"
      `app:actionLayout="@layout/action_layout"`/>

    ...
  </group>
</menu>  
```

- MenuItem#getActionView() で参照を取得
]

???

NavigationView はナビゲーション ドローワーの中のメニューを作るコンポーネント

DrawerLayout に入れて使う。メニュー XML を使う。

- Gmail の未読数など

---

class: normal chapter-2

# その他

.card[
- NavigationView の getHeaderView (23.1.1)  
  XML の app:headerLayout で指定したヘッダーを getHeaderView で取得できる
- バグフィックス
]

---

class: center, middle, hero, chapter-3

# カスタム View の作り方

???

- Design サポート ライブラリはカスタム View のかたまり
- もっとみんなカスタム View を作るべき

---

class: normal, chapter-3

# コンストラクター

.card[
View を直接または間接的に継承し、1 引数のコンストラクターから 3 引数のコンストラクターまで delegate していく

```java
public class NavigationView extends ScrimInsetsFrameLayout {

    public NavigationView(Context context) {
*       this(context, null);
    }

    public NavigationView(Context context, AttributeSet attrs) {
*       this(context, attrs, 0);
    }

    public NavigationView(Context context, AttributeSet attrs,
                          int defStyleAttr) {
*       super(context, attrs, defStyleAttr);

        // 初期化
    }
}
```
]

???

- 例は NavigationView
- 4 引数のコンストラクターを使えばデフォルトのスタイルを指定できるが、 v21 以降なのでいったん忘れよう

---

class: normal, chapter-3

# カスタム属性の定義

.card[
values/attrs.xml にカスタム View と同名の declare-styleable を追加する

```xml
    <declare-styleable name="NavigationView">
        <attr name="android:maxWidth"/>
        <attr name="elevation"/>
        <attr name="itemIconTint" format="color"/>
        <attr name="menu" format="reference"/>
        <attr name="itemBackground" format="reference"/>
    </declare-styleable>
```

- すでに存在する属性 (Android フレームワークや AppCompat などに含まれる属性) には format を付けない
- その View でのみ利用するものは format を付ける
- 複数のカスタム View で共通のカスタム属性を利用する場合は、declare-styleable の外で format 付きの attr 定義をし、declare-styleable の中で format なしの attr 定義をする
]

???

- レイアウト XML に記述する属性名を自分で定義できる
- 対応するメソッドも用意する
- format の方は boolean, color, dimension, integer, reference などがある。enum や flag も定義できる。

---

class: normal, chapter-3

# デフォルトの属性値 (スタイル)

.card[
ユーザーが属性値を指定しなかった場合のデフォルト値を values/styles.xml で定義する。

名前は Widget.[プロジェクト名].[カスタム View 名]
```xml
    <style name="Widget.Design.NavigationView" parent="android:Widget">
        <item name="elevation">@dimen/navigation_elevation</item>
        ...
        <item name="android:maxWidth">@dimen/navigation_max_width</item>
    </style>
```
]

???

---

class: normal, chapter-3

# カスタム属性の値を取得

.card[
コンストラクターの中で属性の値を取得し、カスタム View を初期化する

```java
    // 属性リストを取得
    TypedArray a = context.obtainStyledAttributes(attrs,
            R.styleable.NavigationView, // 属性の定義
            defStyleAttr,
            R.style.Widget_Design_NavigationView); // デフォルトの属性値

    // 属性値を取得
    mMaxWidth = a.getDimensionPixelSize(
            R.styleable.NavigationView_android_maxWidth, 0);
    final Drawable itemBackground = a.getDrawable(
            R.styleable.NavigationView_itemBackground);
    // (略)

    // 忘れずに
    a.recycle();
```
]

???

- 先ほどの 4 引数コンストラクターが使えればこの記述は楽にできるが、v21 でしか使えないので忘れよう

---

class: normal, chapter-3

# レイアウト XML の利用

.card[
```java
public class NavigationMenuItemView extends ForegroundLinearLayout
        implements MenuView.ItemView {

    ...

    public NavigationMenuItemView(Context context, AttributeSet attrs,
                                  int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        setOrientation(HORIZONTAL);
        LayoutInflater.from(context)
            .inflate(R.layout.design_navigation_menu_item, this, `true`);
        ...
```

```xml
<merge xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- LinearLayout の中身 -->
    ...
</merge>
```
]

???

- android.view.View クラスを extends することはあまりないはず
- すでに存在する View、とくに ViewGroup を extends する場合、レイアウト XML が利用できる
- レイアウト XML は merge で始める。そうしないと LinearLayout が二重になる。

---

class: normal, chapter-3

# SavedState の実装

.card[
View.BaseSavedState を継承したインナー クラス SavedState を作る
```java
    public static class SavedState extends BaseSavedState {
        public Bundle menuState;

        public SavedState(Parcel in, ClassLoader loader) {
            super(in);
*           menuState = in.readBundle(loader);
        }

        public SavedState(Parcelable superState) {
            super(superState);
        }

        @Override
        public void writeToParcel(@NonNull Parcel dest, int flags) {
            super.writeToParcel(dest, flags);
*           dest.writeBundle(menuState);
        }

        public static final Parcelable.Creator&lt;SavedState&gt; CREATOR
                = ParcelableCompat.newCreator(new ParcelableCompatCreatorCallbacks&l;SavedState&gt;() {
            @Override
            public SavedState createFromParcel(Parcel parcel, ClassLoader loader) {
                return new SavedState(parcel, loader);
            }

            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        });
    }
```
]
???

- 画面回転時などに、カスタム View の状態を保持するオブジェクト
- 何を保存するべきかよく考える
  - 保存される例: EditText の入力内容, 保存されない例: padding
  - レイアウト XML で指定するもののうち、縦横で切り替える可能性があるもの
- Parcel に複数の値を入れる場合は、書き込む順番と読み込む順番を合わせる

---

class: normal, chapter-3

# SavedState の利用

.card[

```java
    @Override
    protected Parcelable onSaveInstanceState() {
        SavedState state = new SavedState(super.onSaveInstanceState());
*       state.menuState = new Bundle();
*       mMenu.savePresenterStates(state.menuState);
        return state;
    }

    @Override
    protected void onRestoreInstanceState(Parcelable savedState) {
        SavedState state = (SavedState) savedState;
        super.onRestoreInstanceState(state.getSuperState());
*       mMenu.restorePresenterStates(state.menuState);
    }
```

ここまでの内容を押さえておけば簡単なカスタム View は作れるはず
]

---

class: normal, chapter-3

# AppCompat のコンポーネントを継承

.card[
AppCompat なんとか が存在する場合、そちらを継承する

- AppCompatButton
- AppCompatTextView
- AppCompatEditText
- AppCompatCheckBox
- AppCompatRadioButton
- AppCompatSpinner
- etc
]

???

- Design サポート ライブラリでこのパターンはなかった
- AppCompat なんとかには backgroundTint などの機能のバックポートが含まれる
- AppCompat を適切に使っている限り、レイアウト XML で Button タグを使えば、AppCompat が自動的に AppCompatButton を inflate するので、AppCompatButton の存在を意識することはない
- カスタム View に関しては明示的に継承する必要がある

---

class: normal, chapter-3

# アノテーション

.card[
パブリックな API には @NonNull/Nullable や @IdRes, @ColorInt などのアノテーションを適切に付ける
- http://tools.android.com/tech-docs/support-annotations

int を enum 代替として使う場合には独自のアノテーションを定義する

```java
    @IntDef({LENGTH_INDEFINITE, LENGTH_SHORT, LENGTH_LONG})
    @Retention(RetentionPolicy.SOURCE)
    public @interface Duration {}
```

```java
    public static Snackbar make(@NonNull View view,
                                @NonNull CharSequence text,
                                `@Duration` int duration) {
        ...
    }
```
]

???

- @ColorRes と @ColorInt に注意
- 例は Snackbar から

---

class: normal, chapter-3

# 不用意にインターフェイスを実装しない

.card[
```java
public class TextInputLayout extends LinearLayout `implements TextWatcher` {
    private void setEditText(EditText editText) {
        mEditText.addTextChangedListener(`this`);
    }
}
```
.center[
↓
]
```java
public class TextInputLayout extends LinearLayout {
    private void setEditText(EditText editText) {
        mEditText.addTextChangedListener(`mTextWatcher`);
    }
    private final TextWatcher mTextWatcher = new TextWatcher() {
        ...
    };
}
```
]

???

- 例は TextInputLayout、EditText への入力を監視する必要があるので、TextWatcher を使う
- 上の書き方だと、外部からこのクラスのインスタンスを TextWatcher として利用できてしまう

---

class: normal, chapter-3

# 複数のメソッドを持つリスナー

.card[
## 従来のパターン

インターフェイス と 空実装の抽象クラス をそれぞれ用意する

例:  
DrawerLayout.DrawerListener + DrawerLayout.SimpleDrawerListener  
AnimatorListener + AnimatorListenerAdapter

## 新しいパターン

抽象クラスのみ

例:  
FloatingActionButton.OnVisibilityChangedListener
]

???

- すべてのリスナーをこうするべきとは限らない

---

class: normal, chapter-3

# API レベルによって処理を分ける

.card[
```java
public class FloatingActionButton extends ImageButton {
    `private final FloatingActionButtonImpl mImpl`;
    public FloatingActionButton(Context context, AttributeSet attrs,
                                int defStyleAttr) {
        final int sdk = Build.VERSION.SDK_INT;
        if (sdk >= 21) {
            mImpl = new FloatingActionButtonLollipop(this, delegate);
        } else if (sdk >= 14) {
            mImpl = new FloatingActionButtonIcs(this, delegate);
        } else {
            mImpl = new FloatingActionButtonEclairMr1(this, delegate);
        }
    }
    public void show(@Nullable OnVisibilityChangedListener listener) {
        `mImpl.show(wrapOnVisibilityChangedListener(listener))`;
    }
}
```
]

???

- if 文の分岐が増えるとコードが煩雑になってしまう
- FloatingActionButtonImpl は抽象クラスで、API レベルごとの処理が必要なメソッドの空定義が入っている
- FloatingActionButtonEclairMr1 は FloatingActionButtonImpl を拡張していて、すべてのメソッドを EclarMr1 向けに実装している
- FloatingActionButtonIcs は FloatingActionButtonEclairMr1 を拡張していて、Ics で使える機能に置き換えている
- FloatingActionButtonLollipop は FloatingActionButtonIcs を拡張していて、Lollipop で使える機能に置き換えている
- すべての API レベルで共通の処理は FloatingActionButton クラスに直接書く

---

class: normal, chapter-3

# RTL

.card[
]

---

class: hero, center, chapter-5

# <nobr>Design ライブラリについての<wbr>ご意見・ご要望</nobr>

## b.android.com

## @yuichi_araki

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var hljs = remark.highlighter.engine;
    </script>
    <script src="http://gnab.github.io/remark/remark.language.js"></script>
    <script>
      var slideshow = remark.create({
        highlightStyle: 'googlecode',
        highlightLanguage: 'remark',
        highlightLines: true,
        highlightSpans: true
      }) ;
    </script>
  </body>
</html>
